{"ast":null,"code":"import { useCallback, useReducer, useEffect, useState } from \"react\";\nimport { INIT_STATE } from \"../initialState.js\";\n\nfunction useKeyPress(targetKey) {\n  // State for keeping track of whether key is pressed\n  const [keyPressed, setKeyPressed] = useState(false); // If pressed key is our target key then set to true\n\n  function downHandler({\n    key\n  }) {\n    if (key === targetKey) {\n      setKeyPressed(true);\n    }\n  } // If released key is our target key then set to false\n\n\n  const upHandler = ({\n    key\n  }) => {\n    if (key === targetKey) {\n      setKeyPressed(false);\n    }\n  }; // Add event listeners\n\n\n  useEffect(() => {\n    window.addEventListener(\"keydown\", downHandler);\n    window.addEventListener(\"keyup\", upHandler); // Remove event listeners on cleanup\n\n    return () => {\n      window.removeEventListener(\"keydown\", downHandler);\n      window.removeEventListener(\"keyup\", upHandler);\n    };\n  }, []); // Empty array ensures that effect is only run on mount and unmount\n\n  return keyPressed;\n}\n\nexport default function useSnake() {\n  const wPress = useKeyPress(\"w\");\n  const sPress = useKeyPress(\"s\");\n  const aPress = useKeyPress(\"a\");\n  const dPress = useKeyPress(\"d\");\n\n  const snakeRedcuer = (state, action) => {\n    switch (action.type) {\n      case \"MOVE\":\n        if (state.moves[state.moves.length - 1] !== action.direction) {\n          return { ...state,\n            moves: [...state.moves, action.direction]\n          };\n        }\n\n        break;\n\n      default:\n        break;\n    }\n  };\n\n  const [state, dispatch] = useReducer(snakeRedcuer, INIT_STATE);\n  const moveSnakeHandler = useCallback(dir => {\n    switch (dir) {}\n  }, []);\n  return state;\n}","map":{"version":3,"sources":["/Users/qadam/Downloads/snake_game/src/hooks/use-snake.js"],"names":["useCallback","useReducer","useEffect","useState","INIT_STATE","useKeyPress","targetKey","keyPressed","setKeyPressed","downHandler","key","upHandler","window","addEventListener","removeEventListener","useSnake","wPress","sPress","aPress","dPress","snakeRedcuer","state","action","type","moves","length","direction","dispatch","moveSnakeHandler","dir"],"mappings":"AAAA,SAASA,WAAT,EAAsBC,UAAtB,EAAkCC,SAAlC,EAA6CC,QAA7C,QAA6D,OAA7D;AACA,SAASC,UAAT,QAA2B,oBAA3B;;AAEA,SAASC,WAAT,CAAqBC,SAArB,EAAgC;AAC9B;AACA,QAAM,CAACC,UAAD,EAAaC,aAAb,IAA8BL,QAAQ,CAAC,KAAD,CAA5C,CAF8B,CAG9B;;AACA,WAASM,WAAT,CAAqB;AAAEC,IAAAA;AAAF,GAArB,EAA8B;AAC5B,QAAIA,GAAG,KAAKJ,SAAZ,EAAuB;AACrBE,MAAAA,aAAa,CAAC,IAAD,CAAb;AACD;AACF,GAR6B,CAS9B;;;AACA,QAAMG,SAAS,GAAG,CAAC;AAAED,IAAAA;AAAF,GAAD,KAAa;AAC7B,QAAIA,GAAG,KAAKJ,SAAZ,EAAuB;AACrBE,MAAAA,aAAa,CAAC,KAAD,CAAb;AACD;AACF,GAJD,CAV8B,CAe9B;;;AACAN,EAAAA,SAAS,CAAC,MAAM;AACdU,IAAAA,MAAM,CAACC,gBAAP,CAAwB,SAAxB,EAAmCJ,WAAnC;AACAG,IAAAA,MAAM,CAACC,gBAAP,CAAwB,OAAxB,EAAiCF,SAAjC,EAFc,CAGd;;AACA,WAAO,MAAM;AACXC,MAAAA,MAAM,CAACE,mBAAP,CAA2B,SAA3B,EAAsCL,WAAtC;AACAG,MAAAA,MAAM,CAACE,mBAAP,CAA2B,OAA3B,EAAoCH,SAApC;AACD,KAHD;AAID,GARQ,EAQN,EARM,CAAT,CAhB8B,CAwBtB;;AACR,SAAOJ,UAAP;AACD;;AAED,eAAe,SAASQ,QAAT,GAAoB;AACjC,QAAMC,MAAM,GAAGX,WAAW,CAAC,GAAD,CAA1B;AACA,QAAMY,MAAM,GAAGZ,WAAW,CAAC,GAAD,CAA1B;AACA,QAAMa,MAAM,GAAGb,WAAW,CAAC,GAAD,CAA1B;AACA,QAAMc,MAAM,GAAGd,WAAW,CAAC,GAAD,CAA1B;;AAEA,QAAMe,YAAY,GAAG,CAACC,KAAD,EAAQC,MAAR,KAAmB;AACtC,YAAQA,MAAM,CAACC,IAAf;AACE,WAAK,MAAL;AACE,YAAIF,KAAK,CAACG,KAAN,CAAYH,KAAK,CAACG,KAAN,CAAYC,MAAZ,GAAqB,CAAjC,MAAwCH,MAAM,CAACI,SAAnD,EAA8D;AAC5D,iBAAO,EAAE,GAAGL,KAAL;AAAYG,YAAAA,KAAK,EAAE,CAAC,GAAGH,KAAK,CAACG,KAAV,EAAiBF,MAAM,CAACI,SAAxB;AAAnB,WAAP;AACD;;AACD;;AACF;AACE;AAPJ;AASD,GAVD;;AAYA,QAAM,CAACL,KAAD,EAAQM,QAAR,IAAoB1B,UAAU,CAACmB,YAAD,EAAehB,UAAf,CAApC;AAEA,QAAMwB,gBAAgB,GAAG5B,WAAW,CAAE6B,GAAD,IAAS;AAC5C,YAAQA,GAAR;AAED,GAHmC,EAGjC,EAHiC,CAApC;AAKA,SAAOR,KAAP;AACD","sourcesContent":["import { useCallback, useReducer, useEffect, useState } from \"react\";\nimport { INIT_STATE } from \"../initialState.js\";\n\nfunction useKeyPress(targetKey) {\n  // State for keeping track of whether key is pressed\n  const [keyPressed, setKeyPressed] = useState(false);\n  // If pressed key is our target key then set to true\n  function downHandler({ key }) {\n    if (key === targetKey) {\n      setKeyPressed(true);\n    }\n  }\n  // If released key is our target key then set to false\n  const upHandler = ({ key }) => {\n    if (key === targetKey) {\n      setKeyPressed(false);\n    }\n  };\n  // Add event listeners\n  useEffect(() => {\n    window.addEventListener(\"keydown\", downHandler);\n    window.addEventListener(\"keyup\", upHandler);\n    // Remove event listeners on cleanup\n    return () => {\n      window.removeEventListener(\"keydown\", downHandler);\n      window.removeEventListener(\"keyup\", upHandler);\n    };\n  }, []); // Empty array ensures that effect is only run on mount and unmount\n  return keyPressed;\n}\n\nexport default function useSnake() {\n  const wPress = useKeyPress(\"w\");\n  const sPress = useKeyPress(\"s\");\n  const aPress = useKeyPress(\"a\");\n  const dPress = useKeyPress(\"d\");\n\n  const snakeRedcuer = (state, action) => {\n    switch (action.type) {\n      case \"MOVE\":\n        if (state.moves[state.moves.length - 1] !== action.direction) {\n          return { ...state, moves: [...state.moves, action.direction] };\n        }\n        break;\n      default:\n        break;\n    }\n  };\n\n  const [state, dispatch] = useReducer(snakeRedcuer, INIT_STATE);\n\n  const moveSnakeHandler = useCallback((dir) => {\n    switch (dir) {\n    }\n  }, []);\n\n  return state;\n}\n"]},"metadata":{},"sourceType":"module"}